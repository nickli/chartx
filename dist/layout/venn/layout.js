"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.venn=venn,exports.distanceFromIntersectArea=distanceFromIntersectArea,exports.getDistanceMatrices=getDistanceMatrices,exports.bestInitialLayout=bestInitialLayout,exports.constrainedMDSLayout=constrainedMDSLayout,exports.greedyLayout=greedyLayout,exports.lossFunction=lossFunction,exports.disjointCluster=disjointCluster,exports.normalizeSolution=normalizeSolution,exports.scaleSolution=scaleSolution;var _fmin=require("fmin"),_circleintersection=require("./circleintersection");function venn(i,n){(n=n||{}).maxIterations=n.maxIterations||500;var e,t=n.initialLayout||bestInitialLayout,a=n.lossFunction||lossFunction,s=t(i=addMissingAreas(i),n),r=[],o=[];for(e in s)s.hasOwnProperty(e)&&(r.push(s[e].x),r.push(s[e].y),o.push(e));for(var u=(0,_fmin.nelderMead)(function(n){1;for(var e={},t=0;t<o.length;++t){var r=o[t];e[r]={x:n[2*t],y:n[2*t+1],radius:s[r].radius}}return a(e,i)},r,n).x,c=0;c<o.length;++c)e=o[c],s[e].x=u[2*c],s[e].y=u[2*c+1];return s}var SMALL=1e-10;function distanceFromIntersectArea(e,t,r){return Math.min(e,t)*Math.min(e,t)*Math.PI<=r+SMALL?Math.abs(e-t):(0,_fmin.bisect)(function(n){return(0,_circleintersection.circleOverlap)(e,t,n)-r},0,e+t)}function addMissingAreas(n){n=n.slice();var e,t,r,i,a=[],s={};for(e=0;e<n.length;++e){var o=n[e];1==o.sets.length?a.push(o.sets[0]):2==o.sets.length&&(s[[r=o.sets[0],i=o.sets[1]]]=!0,s[[i,r]]=!0)}for(a.sort(function(n,e){return e<n}),e=0;e<a.length;++e)for(r=a[e],t=e+1;t<a.length;++t)[r,i=a[t]]in s||n.push({sets:[r,i],size:0});return n}function getDistanceMatrices(n,a,s){var o=(0,_fmin.zerosM)(a.length,a.length),u=(0,_fmin.zerosM)(a.length,a.length);return n.filter(function(n){return 2==n.sets.length}).map(function(n){var e=s[n.sets[0]],t=s[n.sets[1]],r=distanceFromIntersectArea(Math.sqrt(a[e].size/Math.PI),Math.sqrt(a[t].size/Math.PI),n.size);o[e][t]=o[t][e]=r;var i=0;n.size+1e-10>=Math.min(a[e].size,a[t].size)?i=1:n.size<=1e-10&&(i=-1),u[e][t]=u[t][e]=i}),{distances:o,constraints:u}}function constrainedMDSGradient(n,e,t,r){var i,a=0;for(i=0;i<e.length;++i)e[i]=0;for(i=0;i<t.length;++i)for(var s=n[2*i],o=n[2*i+1],u=i+1;u<t.length;++u){var c=n[2*u],l=n[2*u+1],h=t[i][u],g=r[i][u],f=(c-s)*(c-s)+(l-o)*(l-o),x=Math.sqrt(f),m=f-h*h;0<g&&x<=h||g<0&&h<=x||(a+=2*m*m,e[2*i]+=4*m*(s-c),e[2*i+1]+=4*m*(o-l),e[2*u]+=4*m*(c-s),e[2*u+1]+=4*m*(l-o))}return a}function bestInitialLayout(n,e){var t=greedyLayout(n,e),r=e.lossFunction||lossFunction;if(8<=n.length){var i=constrainedMDSLayout(n,e);r(i,n)+1e-8<r(t,n)&&(t=i)}return t}function constrainedMDSLayout(n,e){var t,r=(e=e||{}).restarts||10,i=[],a={};for(t=0;t<n.length;++t){var s=n[t];1==s.sets.length&&(a[s.sets[0]]=i.length,i.push(s))}var o=getDistanceMatrices(n,i,a),u=o.distances,c=o.constraints,l=(0,_fmin.norm2)(u.map(_fmin.norm2))/u.length;u=u.map(function(n){return n.map(function(n){return n/l})});function h(n,e){return constrainedMDSGradient(n,e,u,c)}var g,f;for(t=0;t<r;++t){var x=(0,_fmin.zeros)(2*u.length).map(Math.random);f=(0,_fmin.conjugateGradient)(h,x,e),(!g||f.fx<g.fx)&&(g=f)}var m=g.x,y={};for(t=0;t<i.length;++t){var d=i[t];y[d.sets[0]]={x:m[2*t]*l,y:m[2*t+1]*l,radius:Math.sqrt(d.size/Math.PI)}}if(e.history)for(t=0;t<e.history.length;++t)(0,_fmin.scale)(e.history[t].x,l);return y}function greedyLayout(n,e){for(var t,r=e&&e.lossFunction?e.lossFunction:lossFunction,i={},a={},s=0;s<n.length;++s){var o=n[s];1==o.sets.length&&(t=o.sets[0],i[t]={x:1e10,y:1e10,rowid:i.length,size:o.size,radius:Math.sqrt(o.size/Math.PI)},a[t]=[])}for(n=n.filter(function(n){return 2==n.sets.length}),s=0;s<n.length;++s){var u=n[s],c=u.hasOwnProperty("weight")?u.weight:1,l=u.sets[0],h=u.sets[1];u.size+SMALL>=Math.min(i[l].size,i[h].size)&&(c=0),a[l].push({set:h,size:u.size,weight:c}),a[h].push({set:l,size:u.size,weight:c})}var g=[];for(t in a)if(a.hasOwnProperty(t)){var f=0;for(s=0;s<a[t].length;++s)f+=a[t][s].size*a[t][s].weight;g.push({set:t,size:f})}function x(n,e){return e.size-n.size}g.sort(x);var m={};function y(n){return n.set in m}function d(n,e){i[e].x=n.x,i[e].y=n.y,m[e]=!0}for(d({x:0,y:0},g[0].set),s=1;s<g.length;++s){var v=g[s].set,p=a[v].filter(y);if(t=i[v],p.sort(x),0===p.length)throw"ERROR: missing pairwise overlap information";for(var M=[],z=0;z<p.length;++z){var R=i[p[z].set],I=distanceFromIntersectArea(t.radius,R.radius,p[z].size);M.push({x:R.x+I,y:R.y}),M.push({x:R.x-I,y:R.y}),M.push({y:R.y+I,x:R.x}),M.push({y:R.y-I,x:R.x});for(var _=z+1;_<p.length;++_)for(var L=i[p[_].set],P=distanceFromIntersectArea(t.radius,L.radius,p[_].size),w=(0,_circleintersection.circleCircleIntersection)({x:R.x,y:R.y,radius:I},{x:L.x,y:L.y,radius:P}),F=0;F<w.length;++F)M.push(w[F])}var S=1e50,A=M[0];for(z=0;z<M.length;++z){i[v].x=M[z].x,i[v].y=M[z].y;var b=r(i,n);b<S&&(S=b,A=M[z])}d(A,v)}return i}function lossFunction(e,n){var t=0;for(var r=0;r<n.length;++r){var i,a=n[r];if(1!=a.sets.length){if(2==a.sets.length){var s=e[a.sets[0]],o=e[a.sets[1]];i=(0,_circleintersection.circleOverlap)(s.radius,o.radius,(0,_circleintersection.distance)(s,o))}else i=(0,_circleintersection.intersectionArea)(a.sets.map(function(n){return e[n]}));t+=(a.hasOwnProperty("weight")?a.weight:1)*(i-a.size)*(i-a.size)}}return t}function orientateCircles(n,e,t){var r;if(null===t?n.sort(function(n,e){return e.radius-n.radius}):n.sort(t),0<n.length){var i=n[0].x,a=n[0].y;for(r=0;r<n.length;++r)n[r].x-=i,n[r].y-=a}2==n.length&&(0,_circleintersection.distance)(n[0],n[1])<Math.abs(n[1].radius-n[0].radius)&&(n[1].x=n[0].x+n[0].radius-n[1].radius-1e-10,n[1].y=n[0].y);if(1<n.length){var s,o,u=Math.atan2(n[1].x,n[1].y)-e,c=Math.cos(u),l=Math.sin(u);for(r=0;r<n.length;++r)s=n[r].x,o=n[r].y,n[r].x=c*s-l*o,n[r].y=l*s+c*o}if(2<n.length){for(var h=Math.atan2(n[2].x,n[2].y)-e;h<0;)h+=2*Math.PI;for(;h>2*Math.PI;)h-=2*Math.PI;if(h>Math.PI){var g=n[1].y/(1e-10+n[1].x);for(r=0;r<n.length;++r){var f=(n[r].x+g*n[r].y)/(1+g*g);n[r].x=2*f-n[r].x,n[r].y=2*f*g-n[r].y}}}}function disjointCluster(n){function e(n){return n.parent!==n&&(n.parent=e(n.parent)),n.parent}n.map(function(n){n.parent=n});for(var t=0;t<n.length;++t)for(var r=t+1;r<n.length;++r){var i=n[t].radius+n[r].radius;(0,_circleintersection.distance)(n[t],n[r])+1e-10<i&&(a=n[r],s=n[t],o=void 0,o=e(a),u=e(s),o.parent=u)}var a,s,o,u,c,l={};for(t=0;t<n.length;++t)(c=e(n[t]).parent.setid)in l||(l[c]=[]),l[c].push(n[t]);n.map(function(n){delete n.parent});var h=[];for(c in l)l.hasOwnProperty(c)&&h.push(l[c]);return h}function getBoundingBox(n){function e(e){return{max:Math.max.apply(null,n.map(function(n){return n[e]+n.radius})),min:Math.min.apply(null,n.map(function(n){return n[e]-n.radius}))}}return{xRange:e("x"),yRange:e("y")}}function normalizeSolution(n,e,t){null===e&&(e=Math.PI/2);var r,i,u=[];for(i in n)if(n.hasOwnProperty(i)){var a=n[i];u.push({x:a.x,y:a.y,radius:a.radius,setid:i})}var s=disjointCluster(u);for(r=0;r<s.length;++r){orientateCircles(s[r],e,t);var o=getBoundingBox(s[r]);s[r].size=(o.xRange.max-o.xRange.min)*(o.yRange.max-o.yRange.min),s[r].bounds=o}s.sort(function(n,e){return e.size-n.size});var c=(u=s[0]).bounds,l=(c.xRange.max-c.xRange.min)/50;function h(n,e,t){if(n){var r,i,a,s=n.bounds;e?r=c.xRange.max-s.xRange.min+l:(r=c.xRange.max-s.xRange.max,(a=(s.xRange.max-s.xRange.min)/2-(c.xRange.max-c.xRange.min)/2)<0&&(r+=a)),t?i=c.yRange.max-s.yRange.min+l:(i=c.yRange.max-s.yRange.max,(a=(s.yRange.max-s.yRange.min)/2-(c.yRange.max-c.yRange.min)/2)<0&&(i+=a));for(var o=0;o<n.length;++o)n[o].x+=r,n[o].y+=i,u.push(n[o])}}for(var g=1;g<s.length;)h(s[g],!0,!1),h(s[g+1],!1,!0),h(s[g+2],!0,!0),g+=3,c=getBoundingBox(u);var f={};for(r=0;r<u.length;++r)f[u[r].setid]=u[r];return f}function scaleSolution(n,e,t,r){var i=[],a=[];for(var s in n)n.hasOwnProperty(s)&&(a.push(s),i.push(n[s]));e-=2*r,t-=2*r;var o=getBoundingBox(i),u=o.xRange,c=o.yRange;if(u.max==u.min||c.max==c.min)return console.log("not scaling solution: zero size detected"),n;for(var l=e/(u.max-u.min),h=t/(c.max-c.min),g=Math.min(h,l),f=(e-(u.max-u.min)*g)/2,x=(t-(c.max-c.min)*g)/2,m={},y=0;y<i.length;++y){var d=i[y];m[a[y]]={radius:g*d.radius,x:r+f+(d.x-u.min)*g,y:r+x+(d.y-c.min)*g}}return m}