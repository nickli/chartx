var rect1 = {
    x : 200,
    y : 200,
    w : 100,
    h : 100,
    rotate : 45,
    rotationOrigin: {},
    points : [
        //旋转之前的顶点
    ],
    vertices : []
}

var rect2 = {
    x : 250,
    y : 250,
    w : 100,
    h : 100,
    rotate : -45,
    rotationOrigin: {},
    points : [
        
    ],
    vertices : []
}


//准备好二维向量函数
function Vec2 (x, y) {
	this.x = x;
	this.y = y;
}
Vec2.distance = function (v1, v2) {
	var dx = v1.x - v2.x,
		dy = v1.y - v2.y;
		
	return Math.sqrt(dx * dx + dy * dy);
};
Vec2.add = function (v1, v2) {
	return new Vec2(v1.x + v2.x, v1.y + v2.y);
};
Vec2.substract = function (v1, v2) {
	return new Vec2(v1.x - v2.x, v1.y - v2.y);
};
Vec2.dot = function (v1, v2) {
	return v1.x * v2.x + v1.y * v2.y;
};
Vec2.prototype = {
	length : function () {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	normalize : function () {
		var l = this.length();

		return new Vec2(this.x / l, this.y / l);
	},

	normL : function () {
		return new Vec2(this.y, -this.x);
	}
};
//设置向量end

function setVertices( rect ){
    rect.points.push( {x: rect.x, y: rect.y} );
    rect.points.push( {x: rect.x + rect.w, y: rect.y} );
    rect.points.push( {x: rect.x + rect.w, y: rect.y+rect.h} );
    rect.points.push( {x: rect.x, y: rect.y+rect.h} );

    rect.rotationOrigin = {x: rect.x + rect.w/2, y:rect.y + rect.h/2 };

    for( var i=0,l=rect.points.length; i<l; i++ ){
        rect.vertices.push( getVertices( rect, i ) )
    }
}

function getVertices( rect, i ){
    var a = rect.rotate * Math.PI / 180;
    var point = rect.points[i];
    var x1 = point.x ,y1 = point.y;
    var vertice,x,y;

    //旋转中心点
    var x0 = rect.rotationOrigin.x;
    var y0 = rect.rotationOrigin.y;

    if( !rect.rotate ){
        x = point.x;
        y = point.y;
    } else {
        if( rect.rotate > 0 ){
            //顺时针
            x = (x1-x0)* Math.cos(a) - (y1-y0)*Math.sin(a) + x0;
            y = (y1-y0)* Math.cos(a) + (x1-x0)*Math.sin(a) + y0;
        } else {
            x = (x1-x0)* Math.cos(a) + (y1-y0)*Math.sin(a) + x0;
            y = (y1-y0)* Math.cos(a) - (x1-x0)*Math.sin(a) + y0;
        }
    }
    vertice = new Vec2(x,y);
    return vertice;
}


//分离轴，投影碰撞检测算法
function polygonsCollisionTest (a, b) {
    var sides = getSides( a ).concat(getSides(b)), axises = new Array();

    for (var j = 0, l = sides.length; j < l; j++) {
        axises.push(sides[j].normL());
    }

    for (var i = 0, len = axises.length; i < len; i++) {
        var axis = axises[i];

        var proA = getProjection(axis, a),
            proB = getProjection(axis, b);

        if (isOverlay(proA, proB)) {
            return false;
        }
    }

    return true;
}

function isOverlay (proA, proB) {
    if (proA.min < proB.min) {
        min = proA.min;
    } else {
        min = proB.min;
    }

    if (proA.max > proB.max) {
        max = proA.max;
    } else {
        max = proB.max;
    }

    return (proA.max - proA.min) + (proB.max - proB.min) < max - min;
}
function getSides( obj ) {
    var list = obj.vertices,
        l = list.length,
        res = new Array();
    if (l >= 3) {
        for (var j = 1, pre = list[0]; j < l; j++) {
            var p = list[j];
            res.push(Vec2.substract(p, pre));
            pre = p;
        }
        res.push(Vec2.substract(list[0], list[l - 1]));
    }
    return res;
}

function getProjection(axis, obj) {
    var list = getRootCoordinate( obj ), min = null, max = null;
    for (var i = 0, l = list.length; i < l; i++) {
        var p = list[i];
        var pro = Vec2.dot(p, axis) / axis.length();
        if (min === null || pro < min) {
            min = pro;
        }
        if (max === null || pro > max) {
            max = pro;
        }
    }
    return {min : min, max : max};
}
function getRootCoordinate(obj) {
    var list = obj.vertices, res = new Array();

    for (var i = 0, l = list.length; i < l; i++) {
        var coord = list[i];
        res.push(new Vec2(coord.x , coord.y));
    }

    return res;
}

setVertices( rect1 );
setVertices( rect2 );
if( polygonsCollisionTest( rect1, rect2 ) ){
    console.log("有相交")
} else {
    console.log("没有相交")
}